// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AppPage {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() counter,
    required TResult Function() inputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? counter,
    TResult? Function()? inputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? counter,
    TResult Function()? inputText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Counter value) counter,
    required TResult Function(InputText value) inputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Counter value)? counter,
    TResult? Function(InputText value)? inputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Counter value)? counter,
    TResult Function(InputText value)? inputText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppPageCopyWith<$Res> {
  factory $AppPageCopyWith(AppPage value, $Res Function(AppPage) then) =
      _$AppPageCopyWithImpl<$Res, AppPage>;
}

/// @nodoc
class _$AppPageCopyWithImpl<$Res, $Val extends AppPage>
    implements $AppPageCopyWith<$Res> {
  _$AppPageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CounterCopyWith<$Res> {
  factory _$$CounterCopyWith(_$Counter value, $Res Function(_$Counter) then) =
      __$$CounterCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CounterCopyWithImpl<$Res>
    extends _$AppPageCopyWithImpl<$Res, _$Counter>
    implements _$$CounterCopyWith<$Res> {
  __$$CounterCopyWithImpl(_$Counter _value, $Res Function(_$Counter) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Counter implements Counter {
  const _$Counter();

  @override
  String toString() {
    return 'AppPage.counter()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Counter);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() counter,
    required TResult Function() inputText,
  }) {
    return counter();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? counter,
    TResult? Function()? inputText,
  }) {
    return counter?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? counter,
    TResult Function()? inputText,
    required TResult orElse(),
  }) {
    if (counter != null) {
      return counter();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Counter value) counter,
    required TResult Function(InputText value) inputText,
  }) {
    return counter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Counter value)? counter,
    TResult? Function(InputText value)? inputText,
  }) {
    return counter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Counter value)? counter,
    TResult Function(InputText value)? inputText,
    required TResult orElse(),
  }) {
    if (counter != null) {
      return counter(this);
    }
    return orElse();
  }
}

abstract class Counter implements AppPage {
  const factory Counter() = _$Counter;
}

/// @nodoc
abstract class _$$InputTextCopyWith<$Res> {
  factory _$$InputTextCopyWith(
          _$InputText value, $Res Function(_$InputText) then) =
      __$$InputTextCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InputTextCopyWithImpl<$Res>
    extends _$AppPageCopyWithImpl<$Res, _$InputText>
    implements _$$InputTextCopyWith<$Res> {
  __$$InputTextCopyWithImpl(
      _$InputText _value, $Res Function(_$InputText) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InputText implements InputText {
  const _$InputText();

  @override
  String toString() {
    return 'AppPage.inputText()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InputText);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() counter,
    required TResult Function() inputText,
  }) {
    return inputText();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? counter,
    TResult? Function()? inputText,
  }) {
    return inputText?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? counter,
    TResult Function()? inputText,
    required TResult orElse(),
  }) {
    if (inputText != null) {
      return inputText();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Counter value) counter,
    required TResult Function(InputText value) inputText,
  }) {
    return inputText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Counter value)? counter,
    TResult? Function(InputText value)? inputText,
  }) {
    return inputText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Counter value)? counter,
    TResult Function(InputText value)? inputText,
    required TResult orElse(),
  }) {
    if (inputText != null) {
      return inputText(this);
    }
    return orElse();
  }
}

abstract class InputText implements AppPage {
  const factory InputText() = _$InputText;
}

/// @nodoc
mixin _$Msg {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() switchToCounter,
    required TResult Function() switchToInputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? switchToCounter,
    TResult? Function()? switchToInputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? switchToCounter,
    TResult Function()? switchToInputText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwitchToCounter value) switchToCounter,
    required TResult Function(SwitchToInputText value) switchToInputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwitchToCounter value)? switchToCounter,
    TResult? Function(SwitchToInputText value)? switchToInputText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwitchToCounter value)? switchToCounter,
    TResult Function(SwitchToInputText value)? switchToInputText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MsgCopyWith<$Res> {
  factory $MsgCopyWith(Msg value, $Res Function(Msg) then) =
      _$MsgCopyWithImpl<$Res, Msg>;
}

/// @nodoc
class _$MsgCopyWithImpl<$Res, $Val extends Msg> implements $MsgCopyWith<$Res> {
  _$MsgCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SwitchToCounterCopyWith<$Res> {
  factory _$$SwitchToCounterCopyWith(
          _$SwitchToCounter value, $Res Function(_$SwitchToCounter) then) =
      __$$SwitchToCounterCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwitchToCounterCopyWithImpl<$Res>
    extends _$MsgCopyWithImpl<$Res, _$SwitchToCounter>
    implements _$$SwitchToCounterCopyWith<$Res> {
  __$$SwitchToCounterCopyWithImpl(
      _$SwitchToCounter _value, $Res Function(_$SwitchToCounter) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SwitchToCounter implements SwitchToCounter {
  const _$SwitchToCounter();

  @override
  String toString() {
    return 'Msg.switchToCounter()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SwitchToCounter);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() switchToCounter,
    required TResult Function() switchToInputText,
  }) {
    return switchToCounter();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? switchToCounter,
    TResult? Function()? switchToInputText,
  }) {
    return switchToCounter?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? switchToCounter,
    TResult Function()? switchToInputText,
    required TResult orElse(),
  }) {
    if (switchToCounter != null) {
      return switchToCounter();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwitchToCounter value) switchToCounter,
    required TResult Function(SwitchToInputText value) switchToInputText,
  }) {
    return switchToCounter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwitchToCounter value)? switchToCounter,
    TResult? Function(SwitchToInputText value)? switchToInputText,
  }) {
    return switchToCounter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwitchToCounter value)? switchToCounter,
    TResult Function(SwitchToInputText value)? switchToInputText,
    required TResult orElse(),
  }) {
    if (switchToCounter != null) {
      return switchToCounter(this);
    }
    return orElse();
  }
}

abstract class SwitchToCounter implements Msg {
  const factory SwitchToCounter() = _$SwitchToCounter;
}

/// @nodoc
abstract class _$$SwitchToInputTextCopyWith<$Res> {
  factory _$$SwitchToInputTextCopyWith(
          _$SwitchToInputText value, $Res Function(_$SwitchToInputText) then) =
      __$$SwitchToInputTextCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwitchToInputTextCopyWithImpl<$Res>
    extends _$MsgCopyWithImpl<$Res, _$SwitchToInputText>
    implements _$$SwitchToInputTextCopyWith<$Res> {
  __$$SwitchToInputTextCopyWithImpl(
      _$SwitchToInputText _value, $Res Function(_$SwitchToInputText) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SwitchToInputText implements SwitchToInputText {
  const _$SwitchToInputText();

  @override
  String toString() {
    return 'Msg.switchToInputText()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SwitchToInputText);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() switchToCounter,
    required TResult Function() switchToInputText,
  }) {
    return switchToInputText();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? switchToCounter,
    TResult? Function()? switchToInputText,
  }) {
    return switchToInputText?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? switchToCounter,
    TResult Function()? switchToInputText,
    required TResult orElse(),
  }) {
    if (switchToInputText != null) {
      return switchToInputText();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwitchToCounter value) switchToCounter,
    required TResult Function(SwitchToInputText value) switchToInputText,
  }) {
    return switchToInputText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwitchToCounter value)? switchToCounter,
    TResult? Function(SwitchToInputText value)? switchToInputText,
  }) {
    return switchToInputText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwitchToCounter value)? switchToCounter,
    TResult Function(SwitchToInputText value)? switchToInputText,
    required TResult orElse(),
  }) {
    if (switchToInputText != null) {
      return switchToInputText(this);
    }
    return orElse();
  }
}

abstract class SwitchToInputText implements Msg {
  const factory SwitchToInputText() = _$SwitchToInputText;
}
